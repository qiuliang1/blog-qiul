<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.82.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title> &middot; My New Hugo Site</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="http://qiul.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="http://qiul.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="http://qiul.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="http://qiul.github.io/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://qiul.github.io/"><h1>My New Hugo Site</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="http://qiul.github.io/">Home</a> </li>
        
      </ul>
    </nav>

    <p>&copy; 2021. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1></h1>
  <time datetime=0001-01-01T00:00:00Z class="post-date">Mon, Jan 1, 0001</time>
  <h1 id="es7-8-新特性">ES7-8 新特性</h1>
<h2 id="ecmascript2016es7">ECMAScript2016(ES7)</h2>
<h3 id="1-判断数组是否包含某个值includes">1. 判断数组是否包含某个值：<code>includes</code></h3>
<p>在<code>includes</code>数组方法还没出现的之前，我们想要判断数组中是否包含某个元素，我们会怎么写：</p>
<ol>
<li>
<p>使用<code>indexOf</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>];
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasOwn</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">n</span>) =&gt; {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">arr</span>.<span style="color:#a6e22e">indexOf</span>(<span style="color:#a6e22e">n</span>) <span style="color:#f92672">!==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
};
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">hasOwn</span>(<span style="color:#ae81ff">1</span>)) {
  <span style="color:#75715e">// do something...
</span><span style="color:#75715e"></span>}
</code></pre></div></li>
<li>
<p>数组遍历</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>];
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasOwn</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">arr</span>, <span style="color:#a6e22e">value</span>) =&gt; {
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">e</span> <span style="color:#66d9ef">of</span> <span style="color:#a6e22e">arr</span>) {
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">value</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">e</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
  }
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
};
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">hasOwn</span>(<span style="color:#a6e22e">arr</span>, <span style="color:#ae81ff">1</span>)) {
  <span style="color:#75715e">// do something...
</span><span style="color:#75715e"></span>}
</code></pre></div></li>
</ol>
<p>而我们使用<code>includes</code>就是一行代码的事情了，就很方便：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>];
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">hasOwn</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">arr</span>.<span style="color:#a6e22e">includes</span>(<span style="color:#ae81ff">1</span>);
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">hasOwn</span>) {
  <span style="color:#75715e">// do something...
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="2-指数运算符-">2. 指数运算符 <code>**</code></h3>
<p><strong>ECMAScript 5.1 (ECMA-262)</strong> 发布出来的指数运算为<code>Math.pow(x,y)</code>:</p>
<blockquote>
<p>Math.pow() 函数返回基数（base）的指数（exponent）次幂，即 base^exponent^ 。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// MDN的例子
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Math.<span style="color:#a6e22e">pow</span>(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">3</span>));
<span style="color:#75715e">// expected output: 343
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Math.<span style="color:#a6e22e">pow</span>(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0.5</span>));
<span style="color:#75715e">// expected output: 2
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Math.<span style="color:#a6e22e">pow</span>(<span style="color:#ae81ff">7</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>));
<span style="color:#75715e">// expected output: 0.02040816326530612
</span><span style="color:#75715e">//                  (1/49)
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Math.<span style="color:#a6e22e">pow</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">0.5</span>));
<span style="color:#75715e">// expected output: NaN
</span></code></pre></div><p><strong>ES7</strong> 发布了<strong>指数运算符</strong>，让指数运算代码更简单：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// MDN的例子
</span><span style="color:#75715e"></span><span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> <span style="color:#ae81ff">3</span>; <span style="color:#75715e">// 8
</span><span style="color:#75715e"></span><span style="color:#ae81ff">3</span> <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">// 9
</span><span style="color:#75715e"></span><span style="color:#ae81ff">3</span> <span style="color:#f92672">**</span> <span style="color:#ae81ff">2.5</span>; <span style="color:#75715e">// 15.588457268119896
</span><span style="color:#75715e"></span><span style="color:#ae81ff">10</span> <span style="color:#f92672">**</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 0.1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">NaN</span> <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">// NaN
</span></code></pre></div><h2 id="ecmascript2017es8">ECMAScript2017(ES8)</h2>
<h3 id="1-异步函数关键字-asyncawait">1. 异步函数关键字 <code>Async/Await</code></h3>
<p>说到异步我们就要回顾一下之前操作异步代码的几种方式（因为主要介绍新特性，这几种方法就不做过多解释）：</p>
<ol>
<li>
<p>嵌套回调<code>callback</code>，直接上代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">asyncFn</span>(<span style="color:#a6e22e">callback</span>) {
  <span style="color:#a6e22e">setTimeout</span>(() =&gt; {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">param</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">a</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span> };
    <span style="color:#a6e22e">callback</span>(<span style="color:#a6e22e">param</span>);
  });
}
<span style="color:#a6e22e">asyncFn</span>((<span style="color:#a6e22e">res</span>) =&gt; {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">res</span>); <span style="color:#75715e">// {a: 1}
</span><span style="color:#75715e"></span>});
</code></pre></div></li>
<li>
<p><code>Promise</code>构造函数</p>
<p>使用<code>Promise</code>之前我们不妨使用<code>console.dir(Promise)</code>在控制台看一看，会发现<code>Promise</code>身上有 all、reject、resolve 这几个眼熟的方法，原型上有 then、catch 等同样很眼熟的方法。所以我们直接<code>new</code>一个：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">promise1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
  <span style="color:#a6e22e">setTimeout</span>(() =&gt; {
    <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;foo&#34;</span>);
  }, <span style="color:#ae81ff">300</span>);
});

<span style="color:#a6e22e">promise1</span>.<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">value</span>) =&gt; {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">value</span>);
  <span style="color:#75715e">// expected output: &#34;foo&#34;
</span><span style="color:#75715e"></span>});
</code></pre></div></li>
<li>
<p>迭代器和生成器<code>Generators</code>函数（<a href="http://www.ruanyifeng.com/blog/2015/04/generator.html">引用于阮一峰</a>）</p>
<blockquote>
<p>Generator 函数是<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B">协程</a>在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">gen</span>(<span style="color:#a6e22e">x</span>) {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">yield</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>;
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">y</span>;
}
</code></pre></div><p>上面代码就是一个 Generator 函数。它不同于普通函数，是可以暂停执行的，所以函数名之前要加星号，以示区别。
整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。Generator 函数的执行方法如下。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">g</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">gen</span>(<span style="color:#ae81ff">1</span>);
<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">next</span>(); <span style="color:#75715e">// { value: 3, done: false }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">next</span>(); <span style="color:#75715e">// { value: undefined, done: true }
</span><span style="color:#75715e"></span><span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">next</span>(); <span style="color:#75715e">// { value: undefined, done: true }
</span></code></pre></div><p>执行过程如下：</p>
<ul>
<li>第一次调用 <code>next</code> 方法时，内部遇到第一个 <code>yield</code> 表达式暂停，返-回后面的结果；</li>
<li>第二次从第一个 <code>yield</code> 表达式开始，遇到 <code>return</code> 暂停，返回<code>return</code> 后面的值 <strong>undefined</strong>，<code>done</code>属性变为<code>true</code>；</li>
<li>第三次调用<code>next</code>方法时，由于函数已经遍历运行完毕，不再有其它状态，因此返回 {value: undefined, done: true}。如果继续调用<code>next</code>方法，返回的也都是这个值</li>
</ul>
</li>
</ol>
<p>回顾完以上三个方式，我们现在步入正题 <code>Async/Await</code>:</p>
<p>我们先来尝试下正常的<code>Async/Await</code>使用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>() {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">promise</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
    <span style="color:#a6e22e">setTimeout</span>(() =&gt; <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;done!&#34;</span>), <span style="color:#ae81ff">1000</span>);
  });

  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">promise</span>; <span style="color:#75715e">// 等待，直到 promise resolve (*)
</span><span style="color:#75715e"></span>
  <span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">result</span>); <span style="color:#75715e">// done!
</span><span style="color:#75715e"></span>}

<span style="color:#a6e22e">f</span>();
</code></pre></div><p>这个函数在执行的时候，“暂停”在了 (*) 那一行，并在 promise 运行完成时，拿到 <code>result</code> 作为结果继续往下执行。所以上面这段代码在一秒后显示 <strong>“done!”</strong>。
相比于 promise.then，它只是获取 promise 的结果的一个更优雅的语法，同时也更易于读写。</p>
<h4 id="async">Async</h4>
<p>再来看一下 <code>Async functions</code> ，单独使用<code>async</code>关键字：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>() {
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
}
<span style="color:#75715e">// 不妨打印一下f()
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">f</span>()); <span style="color:#75715e">// Promise {&lt;fulfilled&gt;: 1}
</span><span style="color:#75715e"></span><span style="color:#a6e22e">f</span>().<span style="color:#a6e22e">then</span>((<span style="color:#a6e22e">e</span>) =&gt; <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">e</span>)); <span style="color:#75715e">// 1
</span></code></pre></div><p>上述代码可以看出<code>async</code>关键字的方法会返回<code>promise</code>对象，所以我们就可以直接按照<code>Promise</code>的方式使用<code>.then()</code>。</p>
<h4 id="await">Await</h4>
<p>关键字 await 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果。
<code>await</code>一直都是配合<code>async</code>使用，那如果单独使用，会发生什么：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript">  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">promise</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Promise((<span style="color:#a6e22e">resolve</span>, <span style="color:#a6e22e">reject</span>) =&gt; {
    <span style="color:#a6e22e">setTimeout</span>(() =&gt; <span style="color:#a6e22e">resolve</span>(<span style="color:#e6db74">&#34;done!&#34;</span>), <span style="color:#ae81ff">1000</span>)
  });
  <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">f</span>() {
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">promise</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">value</span>
  }
  <span style="color:#a6e22e">fn</span>()
  <span style="color:#75715e">// Uncaught SyntaxError: await is only valid in async function
</span></code></pre></div><p>如果函数前面没有 async 关键字，我们就会得到一个语法错误。<code>await</code>必须结合<code>async</code>函数去使用。</p>
<h3 id="2获取对象值组成的数组objectvalues">2.获取对象值组成的数组<code>Object.values()</code></h3>
<p><code>Object.values()</code>的作用与<strong>ES7</strong>的<code>Object.keys()</code>是类似的，前者是获取对象值的集合，后者是获取对象键的集合。</p>
<p>那么使用<code>Object.keys()</code>获取对象值,该如何写：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Obj</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;qlll&#34;</span>, <span style="color:#a6e22e">age</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">22</span> };

<span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Object.<span style="color:#a6e22e">keys</span>(<span style="color:#a6e22e">Obj</span>).<span style="color:#a6e22e">map</span>((<span style="color:#a6e22e">key</span>) =&gt; <span style="color:#a6e22e">Obj</span>[<span style="color:#a6e22e">key</span>])); <span style="color:#75715e">// [&#39;qlll&#39;, 22]
</span></code></pre></div><p>使用<code>Object.keys()</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Object.<span style="color:#a6e22e">values</span>(<span style="color:#a6e22e">Obj</span>)); <span style="color:#75715e">// [&#39;qlll&#39;, 22]
</span></code></pre></div><h3 id="3objectentries">3.Object.entries()</h3>
<p><code>Object.entries()</code>函数返回一个给定对象自身可枚举属性的键值对的数组，算是把<code>Object.keys()</code>和<code>Object.values()</code>拼成了一个二维数组。</p>
<p>先来看下<code>Object.entries()</code>函数返回的是什么样的数据格式:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(Object.<span style="color:#a6e22e">entries</span>(<span style="color:#a6e22e">Obj</span>));
<span style="color:#75715e">/**
</span><span style="color:#75715e">[
</span><span style="color:#75715e">  [&#39;name&#39;, &#39;qlll&#39;],
</span><span style="color:#75715e">  [&#39;age&#39;, 22]
</span><span style="color:#75715e">]
</span><span style="color:#75715e">*/</span>
</code></pre></div><p>这样的数据看上去可能会头痛,那我们在改进一下,让数据更直观一点:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">key</span>,<span style="color:#a6e22e">value</span>] <span style="color:#66d9ef">of</span> Object.<span style="color:#a6e22e">entries</span>(<span style="color:#a6e22e">Obj</span>)) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">`</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">key</span><span style="color:#e6db74">}</span><span style="color:#e6db74">-</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">value</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
}
<span style="color:#75715e">// name-qlll
</span><span style="color:#75715e">// age-22
</span><span style="color:#75715e"></span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">/</span>
</code></pre></div><h3 id="4string-padding">4.String Padding</h3>
<p><strong>String</strong> 新增了两个实例函数, 分别是<code>String.prototype.padStart(targetLength,[padString])</code> 和 <code>String.prototype.padEnd(targetLength,[padString])</code>；允许将空字符串或其他字符串添加到原始字符串的开头或结尾。</p>
<p>由于<code>String.prototype.padStart</code>和<code>String.prototype.padEnd</code>作用相同，只是位置相反，这里我们就以<code>String.prototype.padStart</code>进行讲解。</p>
<blockquote>
<p>String.prototype.padStart(targetLength,[padString])</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">str</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;123&#34;</span>;
<span style="color:#75715e">//  targetLength &lt; string.length
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">padStart</span>(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;19&#34;</span>)); <span style="color:#75715e">// &#39;123&#39;
</span><span style="color:#75715e">//  targetLength &gt; string.length  &amp;&amp; targetLength - string.length &lt; padString
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">padStart</span>(<span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#34;19&#34;</span>)); <span style="color:#75715e">// &#39;1123&#39;
</span><span style="color:#75715e">//  targetLength &gt; string.length  &amp;&amp; targetLength - string.length = padString.length
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">padStart</span>(<span style="color:#ae81ff">5</span>, <span style="color:#e6db74">&#34;19&#34;</span>)); <span style="color:#75715e">// &#39;19123&#39;
</span><span style="color:#75715e">//  targetLength &gt; string.length  &amp;&amp; targetLength - string.length &gt; padString.length
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">padStart</span>(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">&#34;19&#34;</span>)); <span style="color:#75715e">// &#39;19191123&#39;
</span><span style="color:#75715e">// targetLength &gt; string.length &amp;&amp; padString.length 为 null
</span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">str</span>.<span style="color:#a6e22e">padStart</span>(<span style="color:#ae81ff">8</span>)); <span style="color:#75715e">// &#39;     123&#39;
</span></code></pre></div><ul>
<li>targetLength：当前字符串需要填充的目标长度；如果这个数值小于当前字符串的长度，则返回当前字符串本身。</li>
<li>padString(可选)：填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的默认值为 &quot; &ldquo;。</li>
</ul>
<h3 id="5函数参数列表结尾允许逗号">5.函数参数列表结尾允许逗号</h3>
<p>这个特性在多人协作时，对于代码版本管理是很有用的。例如，当我们声明对象或者函数传参时：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fn</span>(
  <span style="color:#a6e22e">param1</span>,
  <span style="color:#a6e22e">param</span>, <span style="color:#75715e">// 新增逗号
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">param2</span> <span style="color:#75715e">//
</span><span style="color:#75715e"></span>) {
  <span style="color:#75715e">// do something...
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">o</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">a</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">1</span>,
  <span style="color:#a6e22e">b</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">2</span>,
};
</code></pre></div><p>当第二个人修改的时候，因为之前已经在后面接上逗号，所以避免在上一行新增逗号，新增参数（或对象属性）就不会检测到上一行也进行了修改。</p>
<h3 id="6objectgetownpropertydescriptors">6.Object.getOwnPropertyDescriptors()</h3>
<p><code>Object.getOwnPropertyDescriptors()</code>函数用来获取一个对象的所有自身属性的描述符,如果没有任何自身属性，则返回空对象。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;wd&#34;</span>,
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">fn</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;fn&#34;</span>;
  },
};
Object.<span style="color:#a6e22e">getOwnPropertyDescriptors</span>(<span style="color:#a6e22e">obj</span>);
<span style="color:#75715e">/* {
</span><span style="color:#75715e">   fn: {
</span><span style="color:#75715e">     configurable: true,
</span><span style="color:#75715e">     enumerable: true,
</span><span style="color:#75715e">     get: fn(),
</span><span style="color:#75715e">     set: undefined
</span><span style="color:#75715e">   },
</span><span style="color:#75715e">   name: {
</span><span style="color:#75715e">     configurable: true
</span><span style="color:#75715e">     enumerable: true
</span><span style="color:#75715e">     value: &#34;wd&#34;
</span><span style="color:#75715e">     writable: true
</span><span style="color:#75715e">   }
</span><span style="color:#75715e"> }
</span><span style="color:#75715e"> */</span>
</code></pre></div><h3 id="7-sharedarraybufferatomics共享内存和原子">7. SharedArrayBuffer、Atomics（共享内存和原子）</h3>
<blockquote>
<p>ES8 引入了两部分内容：新的构造函数 SharedArrayBuffer、具有辅助函数的命名空间对象 Atomics。共享内存是指多个线程并发读写数据，原子能够控制并发，确保多个有竞争关系的线程能够顺利执行</p>
</blockquote>
<p><strong>SharedArrayBuffer</strong> 与 <strong>Atomics</strong> 给 js 带来了多线程的功能，也是 js 引擎的核心改进</p>
<p>新建一个 main.js:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// 创建一个worker进程
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">worker</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Worker</span>(<span style="color:#e6db74">&#34;./work.js&#34;</span>);
<span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">postMessage</span>(<span style="color:#e6db74">&#34;i am mian&#34;</span>);
<span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">onmessage</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">e</span>) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">data</span>);
};
</code></pre></div><p>再新建一个 work.js:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// 创建一个worker进程
</span><span style="color:#75715e"></span><span style="color:#a6e22e">onmessage</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">e</span>) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">data</span>); <span style="color:#75715e">// &#39;i am mian&#39;
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">postMessage</span>(<span style="color:#e6db74">&#34;hello i am work&#34;</span>);
};
</code></pre></div><p>这就是通过 postMessage 实现跨源通信，然后我们再使用 <strong>SharedArrayBuffer</strong>；</p>
<p>main.js:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// 创建一个worker进程
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">worker</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Worker</span>(<span style="color:#e6db74">&#34;./work.js&#34;</span>);

<span style="color:#75715e">// 新建1kb内存
</span><span style="color:#75715e">// SharedArrayBuffer(length) 缓冲区大小  字节byte为单位
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">shareBuffer</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">SharedArrayBuffer</span>(<span style="color:#ae81ff">1024</span>);

<span style="color:#75715e">// 建视图 256个为0的数组
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">intArrBuffer</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Int32Array</span>(<span style="color:#a6e22e">shareBuffer</span>);
<span style="color:#75715e">// 转为256个为递增的数组  方便使用
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">index</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">index</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">intArrBuffer</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">index</span><span style="color:#f92672">++</span>) {
  <span style="color:#a6e22e">intArrBuffer</span>[<span style="color:#a6e22e">index</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">index</span>;
}

<span style="color:#75715e">// postMessage  发送的共享内存地址
</span><span style="color:#75715e"></span><span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">postMessage</span>(<span style="color:#a6e22e">intArrBuffer</span>);
</code></pre></div><p>work.js:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// 创建一个worker进程
</span><span style="color:#75715e"></span><span style="color:#a6e22e">onmessage</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">e</span>) {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrBuffer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">data</span>;
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">arrBuffer</span>);
};
</code></pre></div><p>这个时候我们的 work.js 控制台就会打印出 256 个为递增的数组，那么如果要改某个数据，main.js 是不是也可以共享：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// 创建一个worker进程
</span><span style="color:#75715e"></span><span style="color:#a6e22e">onmessage</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">e</span>) {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrBuffer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">data</span>;
  <span style="color:#a6e22e">arrBuffer</span>[<span style="color:#ae81ff">22</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">88</span>;
  <span style="color:#a6e22e">postMessage</span>(<span style="color:#a6e22e">arrBuffer</span>);
};

<span style="color:#75715e">// --- main.js----
</span><span style="color:#75715e"></span><span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">onmessage</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">e</span>) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;更改后的数据&#34;</span>, <span style="color:#a6e22e">intArrBuffer</span>[<span style="color:#ae81ff">22</span>]); <span style="color:#75715e">// 88
</span><span style="color:#75715e"></span>};
</code></pre></div><p>虽然 mian.js 是能够看到更新后的值，但是直接拿值也是不可取的，如果有其他线程在操作该数据，会造成冲突，所以这个时候我们就要用到<strong>Atomics</strong>(原子)</p>
<blockquote>
<p>Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作,与一般的全局对象不同，Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math 对象一样）。</p>
</blockquote>
<p>现在我们用 <strong>Atomics</strong> 对上面的代码进行改造：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// 创建一个worker进程
</span><span style="color:#75715e"></span><span style="color:#a6e22e">onmessage</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">e</span>) {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrBuffer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">data</span>;
  <span style="color:#75715e">// 返回数组中指定元素的值
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">Atomics</span>.<span style="color:#a6e22e">load</span>(<span style="color:#a6e22e">arrBuffer</span>, <span style="color:#ae81ff">20</span>));
  <span style="color:#75715e">// 给数组指定元素修改值 并返回
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Atomics</span>.<span style="color:#a6e22e">store</span>(<span style="color:#a6e22e">arrBuffer</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">88</span>); <span style="color:#75715e">// 88
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// 将数组中指定的元素更新为给定的值，并返回该元素更新前的值
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Atomics</span>.<span style="color:#a6e22e">exchange</span>(<span style="color:#a6e22e">arrBuffer</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">111</span>); <span style="color:#75715e">// 111
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">postMessage</span>(<span style="color:#a6e22e">arrBuffer</span>);
};

<span style="color:#75715e">// --- main.js----
</span><span style="color:#75715e"></span><span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">onmessage</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">e</span>) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;更改后的数据&#34;</span>, <span style="color:#a6e22e">Atomics</span>.<span style="color:#a6e22e">load</span>(<span style="color:#a6e22e">intArrBuffer</span>, <span style="color:#ae81ff">20</span>)); <span style="color:#75715e">// 111
</span><span style="color:#75715e"></span>};
</code></pre></div><p><strong>其它方法：</strong></p>
<p><code>Atomics.wait()</code>检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时，一般都是配合<code>Atomics.notify()</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#75715e">// 创建一个worker进程
</span><span style="color:#75715e"></span><span style="color:#a6e22e">onmessage</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">e</span>) {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">arrBuffer</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">data</span>;
  <span style="color:#75715e">// 满足条件进入休眠状态，下面是arrBuffer[11]==11时进入休眠
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Atomics</span>.<span style="color:#a6e22e">wait</span>(<span style="color:#a6e22e">arrBuffer</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">11</span>);
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;我是休眠之后要唤醒的地方&#34;</span>);
  <span style="color:#75715e">// postMessage(arrBuffer);
</span><span style="color:#75715e"></span>};

<span style="color:#75715e">// --- main.js----
</span><span style="color:#75715e"></span><span style="color:#a6e22e">setTimeout</span>(() =&gt; {
  <span style="color:#75715e">// 三个参数  共享内存的视图数组   index:视图数据位置   count 唤醒的worker进程数,默认INfinity
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Atomics</span>.<span style="color:#a6e22e">notify</span>(<span style="color:#a6e22e">intArrBuffer</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">1</span>);
}, <span style="color:#ae81ff">3000</span>);
</code></pre></div><p>三秒后执行了<code>Atomics.notify()</code>函数，worker 进程就会继续执行，控制台就会打印出<code>我是休眠之后要唤醒的地方</code>。</p>
<h2 id="参考">参考</h2>
<p><a href="https://juejin.im/post/6844904152963776519">https://juejin.im/post/6844904152963776519</a>
<a href="https://juejin.im/post/6872113750636232712">https://juejin.im/post/6872113750636232712</a></p>

</div>


    </main>

    
      
    
  </body>
</html>
